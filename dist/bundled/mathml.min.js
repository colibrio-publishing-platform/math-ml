"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const directives=new WeakMap,isDirective=e=>"function"==typeof e&&directives.has(e),isCEPolyfill=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,removeNodes=(e,t,n=null)=>{for(let r=t;r!==n;){const t=r.nextSibling;e.removeChild(r),r=t}},noChange={},marker=`{{lit-${(Math.random()+"").slice(2)}}}`,nodeMarker=`<!--${marker}-->`,markerRegex=new RegExp(`${marker}|${nodeMarker}`),rewritesStyleAttribute=(()=>{const e=document.createElement("div");return e.setAttribute("style","{{bad value}}"),"{{bad value}}"!==e.getAttribute("style")})();class Template{constructor(e,t){this.parts=[],this.element=t;let n=-1,r=0;const o=[],a=t=>{const d=t.content,i=document.createTreeWalker(d,133,null,!1);let l,s;for(;i.nextNode();){n++,l=s;const t=s=i.currentNode;if(1===t.nodeType){if(t.hasAttributes()){const o=t.attributes;let a=0;for(let e=0;e<o.length;e++)0<=o[e].value.indexOf(marker)&&a++;for(;0<a--;){const o=e.strings[r],a=lastAttributeNameRegex.exec(o)[2],d=rewritesStyleAttribute&&"style"===a?"style$":/^[a-zA-Z-]*$/.test(a)?a:a.toLowerCase(),i=t.getAttribute(d),l=i.split(markerRegex);this.parts.push({type:"attribute",index:n,name:a,strings:l}),t.removeAttribute(d),r+=l.length-1}}"TEMPLATE"===t.tagName&&a(t)}else if(3===t.nodeType){const e=t.nodeValue;if(0>e.indexOf(marker))continue;const a=t.parentNode,d=e.split(markerRegex),l=d.length-1;r+=l;for(let e=0;e<l;e++)a.insertBefore(""===d[e]?createMarker():document.createTextNode(d[e]),t),this.parts.push({type:"node",index:n++});a.insertBefore(""===d[l]?createMarker():document.createTextNode(d[l]),t),o.push(t)}else if(8===t.nodeType)if(t.nodeValue===marker){const e=t.parentNode,a=t.previousSibling;null===a||a!==l||a.nodeType!==Node.TEXT_NODE?e.insertBefore(createMarker(),t):n--,this.parts.push({type:"node",index:n++}),o.push(t),null===t.nextSibling?e.insertBefore(createMarker(),t):n--,s=l,r++}else for(let e=-1;-1!==(e=t.nodeValue.indexOf(marker,e+1));)this.parts.push({type:"node",index:-1})}};a(t);for(const r of o)r.parentNode.removeChild(r)}}const isTemplatePartActive=e=>-1!==e.index,createMarker=()=>document.createComment(""),lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;class TemplateInstance{constructor(e,t,n){this._parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this._parts)void 0!==n&&n.setValue(e[t]),t++;for(const t of this._parts)void 0!==t&&t.commit()}_clone(){const e=isCEPolyfill?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=this.template.parts;let n=0,r=0;const o=e=>{const a=document.createTreeWalker(e,133,null,!1);for(let d=a.nextNode();n<t.length&&null!==d;){const e=t[n];if(!isTemplatePartActive(e))this._parts.push(void 0),n++;else if(r===e.index){if("node"===e.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(d),this._parts.push(e)}else this._parts.push(...this.processor.handleAttributeExpressions(d,e.name,e.strings,this.options));n++}else r++,"TEMPLATE"===d.nodeName&&o(d.content),d=a.nextNode()}};return o(e),isCEPolyfill&&(document.adoptNode(e),customElements.upgrade(e)),e}}class TemplateResult{constructor(e,t,n,r){this.strings=e,this.values=t,this.type=n,this.processor=r}getHTML(){const e=this.strings.length-1;let t="",n=!0;for(let r=0;r<e;r++){const e=this.strings[r];t+=e;const o=e.lastIndexOf(">");n=(-1<o||n)&&-1===e.indexOf("<",o+1),!n&&rewritesStyleAttribute&&(t=t.replace(lastAttributeNameRegex,(e,t,n,r)=>"style"===n?`${t}style$${r}`:e)),t+=n?nodeMarker:marker}return t+=this.strings[e],t}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}const isPrimitive=e=>null===e||"object"!=typeof e&&"function"!=typeof e;class AttributeCommitter{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let r=0;r<n.length-1;r++)this.parts[r]=this._createPart()}_createPart(){return new AttributePart(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let r=0;r<t;r++){n+=e[r];const t=this.parts[r];if(void 0!==t){const e=t.value;if(null!=e&&(Array.isArray(e)||"string"!=typeof e&&e[Symbol.iterator]))for(const r of e)n+="string"==typeof r?r:r+"";else n+="string"==typeof e?e:e+""}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class AttributePart{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===noChange||isPrimitive(e)&&e===this.value||(this.value=e,!isDirective(e)&&(this.committer.dirty=!0))}commit(){for(;isDirective(this.value);){const e=this.value;this.value=noChange,e(this)}this.value===noChange||this.committer.commit()}}class NodePart{constructor(e){this.value=void 0,this._pendingValue=void 0,this.options=e}appendInto(e){this.startNode=e.appendChild(createMarker()),this.endNode=e.appendChild(createMarker())}insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}appendIntoPart(e){e._insert(this.startNode=createMarker()),e._insert(this.endNode=createMarker())}insertAfterPart(e){e._insert(this.startNode=createMarker()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}const e=this._pendingValue;e===noChange||(isPrimitive(e)?e!==this.value&&this._commitText(e):e instanceof TemplateResult?this._commitTemplateResult(e):e instanceof Node?this._commitNode(e):Array.isArray(e)||e[Symbol.iterator]?this._commitIterable(e):e.then===void 0?this._commitText(e):this._commitPromise(e))}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_commitNode(e){this.value===e||(this.clear(),this._insert(e),this.value=e)}_commitText(e){const t=this.startNode.nextSibling;e=null==e?"":e,t===this.endNode.previousSibling&&t.nodeType===Node.TEXT_NODE?t.textContent=e:this._commitNode(document.createTextNode("string"==typeof e?e:e+"")),this.value=e}_commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value&&this.value.template===t)this.value.update(e.values);else{const n=new TemplateInstance(t,e.processor,this.options),r=n._clone();n.update(e.values),this._commitNode(r),this.value=n}}_commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());const t=this.value;let n,r=0;for(const o of e)n=t[r],void 0===n&&(n=new NodePart(this.options),t.push(n),0==r?n.appendIntoPart(this):n.insertAfterPart(t[r-1])),n.setValue(o),n.commit(),r++;r<t.length&&(t.length=r,this.clear(n&&n.endNode))}_commitPromise(e){this.value=e,e.then(t=>{this.value===e&&(this.setValue(t),this.commit())})}clear(e=this.startNode){removeNodes(this.startNode.parentNode,e.nextSibling,this.endNode)}}class BooleanAttributePart{constructor(e,t,n){if(this.value=void 0,this._pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}if(this._pendingValue!==noChange){const e=!!this._pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=e,this._pendingValue=noChange}}}class PropertyCommitter extends AttributeCommitter{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new PropertyPart(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class PropertyPart extends AttributePart{}let eventOptionsSupported=!1;try{const e={get capture(){return eventOptionsSupported=!0,!1}};window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class EventPart{constructor(e,t,n){this.value=void 0,this._pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}if(this._pendingValue===noChange)return;const e=this._pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive);n&&this.element.removeEventListener(this.eventName,this,this._options),this._options=getOptions(e),null!=e&&(null==t||n)&&this.element.addEventListener(this.eventName,this,this._options),this.value=e,this._pendingValue=noChange}handleEvent(e){const t="function"==typeof this.value?this.value:"function"==typeof this.value.handleEvent?this.value.handleEvent:()=>null;t.call(this.eventContext||this.element,e)}}const getOptions=e=>e&&(eventOptionsSupported?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);class DefaultTemplateProcessor{handleAttributeExpressions(e,t,n,r){const o=t[0];if("."===o){const r=new PropertyCommitter(e,t.slice(1),n);return r.parts}if("@"===o)return[new EventPart(e,t.slice(1),r.eventContext)];if("?"===o)return[new BooleanAttributePart(e,t.slice(1),n)];const a=new AttributeCommitter(e,t,n);return a.parts}handleTextExpression(e){return new NodePart(e)}}const defaultTemplateProcessor=new DefaultTemplateProcessor;function templateFactory(e){let t=templateCaches.get(e.type);void 0===t&&(t=new Map,templateCaches.set(e.type,t));let n=t.get(e.strings);return void 0===n&&(n=new Template(e,e.getTemplateElement()),t.set(e.strings,n)),n}const templateCaches=new Map,parts=new WeakMap,render=(e,t,n)=>{let r=parts.get(t);r===void 0&&(removeNodes(t,t.firstChild),parts.set(t,r=new NodePart(Object.assign({templateFactory},n))),r.appendInto(t)),r.setValue(e),r.commit()},html=(e,...t)=>new TemplateResult(e,t,"html",defaultTemplateProcessor),walkerNodeFilter=NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT;function removeNodesFromTemplate(e,t){const{element:{content:r},parts:n}=e,o=document.createTreeWalker(r,walkerNodeFilter,null,!1);let a=nextActiveIndexInTemplateParts(n),d=n[a],i=-1,l=0;const s=[];for(let r=null;o.nextNode();){i++;const e=o.currentNode;for(e.previousSibling===r&&(r=null),t.has(e)&&(s.push(e),null===r&&(r=e)),null!==r&&l++;d!==void 0&&d.index===i;)d.index=null===r?d.index-l:-1,a=nextActiveIndexInTemplateParts(n,a),d=n[a]}s.forEach(e=>e.parentNode.removeChild(e))}const countNodes=e=>{let t=e.nodeType===Node.DOCUMENT_FRAGMENT_NODE?0:1;for(const n=document.createTreeWalker(e,walkerNodeFilter,null,!1);n.nextNode();)t++;return t},nextActiveIndexInTemplateParts=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(isTemplatePartActive(t))return n}return-1};function insertNodeIntoTemplate(e,t,n=null){const{element:{content:o},parts:r}=e;if(null===n||void 0===n)return void o.appendChild(t);const a=document.createTreeWalker(o,walkerNodeFilter,null,!1);let d=nextActiveIndexInTemplateParts(r),i=0,l=-1;for(;a.nextNode();){l++;const e=a.currentNode;for(e===n&&(i=countNodes(t),n.parentNode.insertBefore(t,n));-1!==d&&r[d].index===l;){if(0<i){for(;-1!==d;)r[d].index+=i,d=nextActiveIndexInTemplateParts(r,d);return}d=nextActiveIndexInTemplateParts(r,d)}}}const getTemplateCacheKey=(e,t)=>`${e}--${t}`;let compatibleShadyCSSVersion=!0;"undefined"==typeof window.ShadyCSS?compatibleShadyCSSVersion=!1:"undefined"==typeof window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),compatibleShadyCSSVersion=!1);const shadyTemplateFactory=e=>t=>{const n=getTemplateCacheKey(t.type,e);let r=templateCaches.get(n);r===void 0&&(r=new Map,templateCaches.set(n,r));let o=r.get(t.strings);if(o===void 0){const n=t.getTemplateElement();compatibleShadyCSSVersion&&window.ShadyCSS.prepareTemplateDom(n,e),o=new Template(t,n),r.set(t.strings,o)}return o},TEMPLATE_TYPES=["html","svg"],removeStylesFromLitTemplates=e=>{TEMPLATE_TYPES.forEach(t=>{const n=templateCaches.get(getTemplateCacheKey(t,e));n!==void 0&&n.forEach(e=>{const{element:{content:t}}=e,n=new Set;Array.from(t.querySelectorAll("style")).forEach(e=>{n.add(e)}),removeNodesFromTemplate(e,n)})})},shadyRenderSet=new Set,prepareTemplateStyles=(e,t,n)=>{shadyRenderSet.add(n);const r=e.querySelectorAll("style");if(0!==r.length){const o=document.createElement("style");for(let e=0;e<r.length;e++){const t=r[e];t.parentNode.removeChild(t),o.textContent+=t.textContent}if(removeStylesFromLitTemplates(n),insertNodeIntoTemplate(t,o,t.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(t.element,n),window.ShadyCSS.nativeShadow){const n=t.element.content.querySelector("style");e.insertBefore(n.cloneNode(!0),e.firstChild)}else{t.element.content.insertBefore(o,t.element.content.firstChild);const e=new Set;e.add(o),removeNodesFromTemplate(t,e)}}},render$1=(e,t,n)=>{const r=n.scopeName,o=parts.has(t);if(render(e,t,Object.assign({templateFactory:shadyTemplateFactory(r)},n)),t instanceof ShadowRoot&&compatibleShadyCSSVersion&&e instanceof TemplateResult){if(!shadyRenderSet.has(r)){const e=parts.get(t),n=e.value;prepareTemplateStyles(t,n.template,r)}o||window.ShadyCSS.styleElement(t.host)}},fromBooleanAttribute=e=>null!==e,toBooleanAttribute=e=>e?"":null,notEqual=(e,t)=>t!==e&&(t===t||e===e),defaultPropertyDeclaration={attribute:!0,type:String,reflect:!1,hasChanged:notEqual},microtaskPromise=new Promise(e=>e(!0)),STATE_HAS_UPDATED=1,STATE_UPDATE_REQUESTED=4,STATE_IS_REFLECTING=8;class UpdatingElement extends HTMLElement{constructor(){super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=microtaskPromise,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}static get observedAttributes(){this._finalize();const e=[];for(const[t,n]of this._classProperties){const r=this._attributeNameForProperty(t,n);r!==void 0&&(this._attributeToPropertyMap.set(r,t),e.push(r))}return e}static createProperty(e,t=defaultPropertyDeclaration){if(!this.hasOwnProperty("_classProperties")){this._classProperties=new Map;const e=Object.getPrototypeOf(this)._classProperties;void 0!==e&&e.forEach((e,t)=>this._classProperties.set(t,e))}if(this._classProperties.set(e,t),this.prototype.hasOwnProperty(e))return;const n="symbol"==typeof e?Symbol():`__${e}`;Object.defineProperty(this.prototype,e,{get(){return this[n]},set(r){const o=this[e];this[n]=r,this._requestPropertyUpdate(e,o,t)},configurable:!0,enumerable:!0})}static _finalize(){if(this.hasOwnProperty("_finalized")&&this._finalized)return;const e=Object.getPrototypeOf(this);"function"==typeof e._finalize&&e._finalize(),this._finalized=!0,this._attributeToPropertyMap=new Map;const t=this.properties,n=[...Object.getOwnPropertyNames(t),...("function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(t):[])];for(const e of n)this.createProperty(e,t[e])}static _attributeNameForProperty(e,t){const n=t!==void 0&&t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}static _valueHasChanged(e,t,n=notEqual){return n(e,t)}static _propertyValueFromAttribute(e,t){const n=t&&t.type;if(n===void 0)return e;const r=n===Boolean?fromBooleanAttribute:"function"==typeof n?n:n.fromAttribute;return r?r(e):e}static _propertyValueToAttribute(e,t){if(void 0!==t&&void 0!==t.reflect){const n=t.type===Boolean?toBooleanAttribute:t.type&&t.type.toAttribute||String;return n(e)}}initialize(){this.renderRoot=this.createRenderRoot(),this._saveInstanceProperties()}_saveInstanceProperties(){for(const[e]of this.constructor._classProperties)if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}}_applyInstanceProperties(){for(const[e,t]of this._instanceProperties)this[e]=t;this._instanceProperties=void 0}createRenderRoot(){return this.attachShadow({mode:"open"})}connectedCallback(){this._updateState&STATE_HAS_UPDATED?window.ShadyCSS!==void 0&&window.ShadyCSS.styleElement(this):this.requestUpdate()}disconnectedCallback(){}attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=defaultPropertyDeclaration){const r=this.constructor,o=r._propertyValueToAttribute(t,n);if(o!==void 0){const t=r._attributeNameForProperty(e,n);t!==void 0&&(this._updateState|=STATE_IS_REFLECTING,null===o?this.removeAttribute(t):this.setAttribute(t,o),this._updateState&=~STATE_IS_REFLECTING)}}_attributeToProperty(e,t){if(!(this._updateState&STATE_IS_REFLECTING)){const n=this.constructor,r=n._attributeToPropertyMap.get(e);if(r!==void 0){const e=n._classProperties.get(r);this[r]=n._propertyValueFromAttribute(t,e)}}}requestUpdate(e,t){if(e!==void 0){const n=this.constructor._classProperties.get(e)||defaultPropertyDeclaration;return this._requestPropertyUpdate(e,t,n)}return this._invalidate()}_requestPropertyUpdate(e,t,n){return this.constructor._valueHasChanged(this[e],t,n.hasChanged)?(this._changedProperties.has(e)||this._changedProperties.set(e,t),!0===n.reflect&&(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,n)),this._invalidate()):this.updateComplete}async _invalidate(){if(!this._hasRequestedUpdate){this._updateState|=STATE_UPDATE_REQUESTED;let e;const t=this._updatePromise;this._updatePromise=new Promise(t=>e=t),await t,this._validate(),e(!this._hasRequestedUpdate)}return this.updateComplete}get _hasRequestedUpdate(){return this._updateState&STATE_UPDATE_REQUESTED}_validate(){if(this._instanceProperties&&this._applyInstanceProperties(),this.shouldUpdate(this._changedProperties)){const e=this._changedProperties;this.update(e),this._markUpdated(),this._updateState&STATE_HAS_UPDATED||(this._updateState|=STATE_HAS_UPDATED,this.firstUpdated(e)),this.updated(e)}else this._markUpdated()}_markUpdated(){this._changedProperties=new Map,this._updateState&=~STATE_UPDATE_REQUESTED}get updateComplete(){return this._updatePromise}shouldUpdate(){return!0}update(){if(this._reflectingProperties!==void 0&&0<this._reflectingProperties.size){for(const[e,t]of this._reflectingProperties)this._propertyToAttribute(e,this[e],t);this._reflectingProperties=void 0}}updated(){}firstUpdated(){}}UpdatingElement._attributeToPropertyMap=new Map,UpdatingElement._finalized=!0,UpdatingElement._classProperties=new Map,UpdatingElement.properties={};const customElement=e=>t=>(window.customElements.define(e,t),t),property=e=>(t,n)=>{t.constructor.createProperty(n,e)};class LitElement extends UpdatingElement{update(e){super.update(e);const t=this.render();t instanceof TemplateResult&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this})}render(){}}LitElement.render=render$1;var __decorate=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};class MathMLElement extends LitElement{updated(e){e.has("mathcolor")&&this.style.setProperty("--math-color",this.mathcolor||null),e.has("mathbackground")&&this.style.setProperty("--math-background",this.mathbackground||null)}}__decorate([property({type:String}),__metadata("design:type",String)],MathMLElement.prototype,"mathbackground",void 0),__decorate([property({type:String}),__metadata("design:type",String)],MathMLElement.prototype,"mathcolor",void 0);function element(e){return customElement(e)}var __decorate$1=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        font-size: inherit;
        font-style: normal;
        font-family: serif;
        line-height: 1.5;
        word-spacing: normal;
        letter-spacing: normal;
        text-rendering: optimizeLegibility;
        direction: ltr;
        unicode-bidi: embed;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}},exports.MathElement=__decorate$1([element("math-ml")],exports.MathElement);const horizontal=`.layout.horizontal {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}`,vertical=`.layout.vertical {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}`,flex=`.flex {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}`,center=`.center {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}`,AllFlex=html`
  ${vertical}
  ${".layout.horizontal {\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -ms-flex-direction: row;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}"}
  ${flex}
  ${center}
`,VertFlex=html`
  ${vertical}
  ${flex}
`,HorizFlex=html`
  ${".layout.horizontal {\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -ms-flex-direction: row;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}"}
  ${flex}
`,HorizCenterFlex=html`
  ${".layout.horizontal {\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -ms-flex-direction: row;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}"}
  ${flex}
  ${center}
`;var __decorate$2=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathRowElement=class extends MathMLElement{render(){return html`
    <style>
      ${HorizFlex}
      :host {
        display: inline-block;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      .layout.horizontal {
        align-items: baseline;
      }
      .layout.horizontal.centered {
        align-items: center;
      }
      .layout.horizontal.justified {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      }
    </style>
    <div id="mrowPanel" class="horizontal layout"><slot @slotchange="${this.onSlotChange}"></slot></div>
    `}onSlotChange(){if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("slot"),t=this.shadowRoot.querySelector("#mrowPanel");if(!e||!t)return;t.classList.remove("centered");const n=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);let r=0,o=0,a=!1;for(let e=0;e<n.length;e++){const t=(n[e].textContent||"").trim();if("="===t){a=!0;break}const d=n[e].tagName.toLowerCase();switch(d){case"math-underover":case"math-under":case"math-over":case"math-subsup":o++;break;case"math-o":r++;break;case"math-table":a=!0;break;default:}}a||!o||r||(a=!0),a&&t.classList.add("centered"),t.classList.remove("justified"),("center"===(getComputedStyle(this).getPropertyValue("--math-underover-align")||"").trim()||"center"===(getComputedStyle(this).getPropertyValue("--math-under-align")||"").trim()||"center"===(getComputedStyle(this).getPropertyValue("--math-over-align")||"").trim())&&t.classList.add("justified")}},exports.MathRowElement=__decorate$2([element("math-row")],exports.MathRowElement);var __decorate$3=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathNElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}},exports.MathNElement=__decorate$3([element("math-n")],exports.MathNElement);var __decorate$4=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$1=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathOElement=class extends MathMLElement{constructor(){super(...arguments),this.formStyle=""}render(){return html`
    <style>
      :host {
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
        position: relative;
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      :host(.mo-infix) {
        margin: 0 0.2em;
      }
      :host(.mo-separator) {
        margin: 0 0.2em 0 0;
      }
      :host(.mo-product) {
        margin: 0;
      }
      :host(.mo-begin-brace) {
        margin: 0 0.05em 0 0.2em;
      }
      :host(.mo-end-brace) {
        margin: 0 0.2em 0 0.05em;
      }
      :host(.mo-neut-brace) {
        margin: 0 0.16em;
      }
      :host(.mo-stretchy) {
        align-self: stretch;
      }
      :host(.mo-bigger) {
        line-height: 1.1;
        font-size: 1.8em;
      }
      .invisible {
        opacity: 0;
      }
      .fullWidthSpan {
        width: 100%;
        box-sizing: border-box;
        text-align: center;
      }
    </style>
    <span class="invisible"><slot @slotchange="${this.onSlotChange}"></slot></span>
    `}updated(e){super.updated(e),this.onSlotChange()}onSlotChange(){if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("span");if(!e)return;let t="";const n=(this.textContent||"").trim();","===n||";"===n?t="separator":"."===n||"\u22C5"===n?t="product":n.match(/^[\[{(]*$/)?t="begin-brace":n.match(/^[\]})]*$/)?t="end-brace":n.match(/^[|]*$/)&&(t="neut-brace"),this.classList.remove("mo-bigger"),n&&8704<=n.charCodeAt(0)&&8755>=n.charCodeAt(0)&&"sub"!==(getComputedStyle(this).getPropertyValue("--math-style-level")||"").trim()&&this.classList.add("mo-bigger");const r=t||"infix";this.formStyle!==r&&(this.formStyle&&this.classList.remove(this.formStyle),this.formStyle=`mo-${r}`,this.classList.add(this.formStyle));let o=this.stretchy&&"true"===this.stretchy.trim().toLowerCase();this.stretchy||("true"===getComputedStyle(this).getPropertyValue("--math-style-stretchy").trim()?o=!0:o="begin-brace"==t||"end-brace"==t||"neut-brace"==t),e.style.width=null,o?(e.classList.remove("fullWidthSpan"),this.classList.add("mo-stretchy"),e.style.lineHeight="1",setTimeout(()=>{if(e.style.transform)return;e.classList.remove("invisible");const t=e.getBoundingClientRect(),n=this.getBoundingClientRect(),r=t.height?n.height/t.height:1,o=t.width?n.width/t.width:1;1>=r&&(e.style.lineHeight=null),1!==o&&(e.style.width="100%"),e.style.transform=`scale(${o}, ${r})`},50)):(e.classList.add("fullWidthSpan"),this.classList.remove("mo-stretchy"),e.style.transform=null,e.style.lineHeight=null,e.classList.remove("invisible"))}},__decorate$4([property({type:String}),__metadata$1("design:type",String)],exports.MathOElement.prototype,"form",void 0),__decorate$4([property({type:String}),__metadata$1("design:type",String)],exports.MathOElement.prototype,"stretchy",void 0),exports.MathOElement=__decorate$4([element("math-o")],exports.MathOElement);var __decorate$5=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathIElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        font-style: italic;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}},exports.MathIElement=__decorate$5([element("math-i")],exports.MathIElement);var __decorate$6=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$2=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathSElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      :host:before {
        content: "\\0022";
        margin-right: -0.2em;
      }
      :host:after {
        content: "\\0022";
        margin-left: -0.2em;
      }
      :host([lquote]):before {
        content: attr(lquote)
      }
      :host([rquote]):after {
        content: attr(rquote)
      }
    </style>
    <slot></slot>
    `}},__decorate$6([property({type:String,reflect:!0}),__metadata$2("design:type",String)],exports.MathSElement.prototype,"lquote",void 0),__decorate$6([property({type:String,reflect:!0}),__metadata$2("design:type",String)],exports.MathSElement.prototype,"rquote",void 0),exports.MathSElement=__decorate$6([element("math-s")],exports.MathSElement);var __decorate$7=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$3=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathSpaceElement=class extends MathMLElement{constructor(){super(...arguments),this.width="0em",this.height="0ex",this.depth="0ex"}render(){return html`
    <style>
      :host {
        display: inline-block;
        vertical-align: top;
        background: var(--math-background, inherit);
      }
    </style>
    `}updated(e){super.updated(e),this.style.width=this.width,this.style.height=this.height,this.style.marginBottom=this.depth}},__decorate$7([property({type:String}),__metadata$3("design:type",Object)],exports.MathSpaceElement.prototype,"width",void 0),__decorate$7([property({type:String}),__metadata$3("design:type",Object)],exports.MathSpaceElement.prototype,"height",void 0),__decorate$7([property({type:String}),__metadata$3("design:type",Object)],exports.MathSpaceElement.prototype,"depth",void 0),exports.MathSpaceElement=__decorate$7([element("math-space")],exports.MathSpaceElement);var __decorate$8=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathTextElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        white-space: nowrap;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}},exports.MathTextElement=__decorate$8([element("math-text")],exports.MathTextElement);var __decorate$9=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$4=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathGlyphElement=class extends MathMLElement{constructor(){super(...arguments),this.width="auto",this.height="auto",this.valign="auto",this.alt=""}render(){const e=this.valign?0===this.valign.indexOf("-")?this.valign.substring(1):`-${this.valign}`:"0",t=this.src?`width: ${this.width||"auto"}; height: ${this.height||"auto"}; transform: translate3d(0,${e},0);`:"display: none;";return html`
    <style>
      :host {
        display: inline-block;
        background: var(--math-background, inherit);
      }
      img {
        display: block;
      }
    </style>
    <img src="${this.src||""}" alt="${this.alt}" style="${t}">
    `}},__decorate$9([property({type:String}),__metadata$4("design:type",String)],exports.MathGlyphElement.prototype,"src",void 0),__decorate$9([property({type:String}),__metadata$4("design:type",Object)],exports.MathGlyphElement.prototype,"width",void 0),__decorate$9([property({type:String}),__metadata$4("design:type",Object)],exports.MathGlyphElement.prototype,"height",void 0),__decorate$9([property({type:String}),__metadata$4("design:type",Object)],exports.MathGlyphElement.prototype,"valign",void 0),__decorate$9([property({type:String}),__metadata$4("design:type",Object)],exports.MathGlyphElement.prototype,"alt",void 0),exports.MathGlyphElement=__decorate$9([element("math-glyph")],exports.MathGlyphElement);var __decorate$a=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$5=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};class MathTableBaseElement extends MathMLElement{updateAlignment(){const e=this.style;if(this.columnalign)switch(this.columnalign){case"left":e.setProperty("--math-ml-columnalign","left");break;case"right":e.setProperty("--math-ml-columnalign","right");break;default:case"center":e.setProperty("--math-ml-columnalign","center");}if(this.rowalign)switch(this.rowalign){case"baseline":e.setProperty("--math-ml-rowalign","baseline");break;case"bottom":e.setProperty("--math-ml-rowalign","bottom");break;case"axis":case"center":e.setProperty("--math-ml-rowalign","middle");break;case"top":e.setProperty("--math-ml-rowalign","top");break;default:e.removeProperty("--math-ml-rowalign");}}}__decorate$a([property({type:String}),__metadata$5("design:type",String)],MathTableBaseElement.prototype,"columnalign",void 0),__decorate$a([property({type:String}),__metadata$5("design:type",String)],MathTableBaseElement.prototype,"rowalign",void 0);var __decorate$b=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathTDElement=class extends MathTableBaseElement{render(){return html`
    <style>
      :host {
        display: table-cell;
        text-align: var(--math-ml-columnalign);
        vertical-align: var(--math-ml-rowalign);
        padding-left: var(--math-table-columnspacing);
        padding-right: var(--math-table-columnspacing);
        padding-top: var(--math-table-rowspacing);
        padding-bottom: var(--math-table-rowspacing);
        padding-left: calc(var(--math-table-columnspacing)/2);
        padding-right: calc(var(--math-table-columnspacing)/2);
        padding-top: calc(var(--math-table-rowspacing)/2);
        padding-bottom: calc(var(--math-table-rowspacing)/2);
        border-bottom: var(--math-table-row-border);
        border-right: var(--math-table-column-border);
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}updated(e){super.updated(e),this.updateAlignment()}},exports.MathTDElement=__decorate$b([element("math-td")],exports.MathTDElement);var __decorate$c=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathTRElement=class extends MathTableBaseElement{render(){return html`
    <style>
      :host {
        display: table-row;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      slot::slotted(math-td:last-child) {
        --math-table-column-border: none;
      }
    </style>
    <slot @slotchange="${this.refreshSlot}"></slot>
    `}updated(e){super.updated(e),this.updateAlignment(),this.refreshSlot()}refreshSlot(){if(this.shadowRoot){const e=this.shadowRoot.querySelector("slot");if(e&&this.columnalign){const t=this.columnalign.trim().split(" ").filter(e=>!!e.trim());if(1<t.length){const n=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE).filter(e=>"MATH-TD"===e.tagName);for(let e=0;e<t.length&&!(e>=n.length);e++)n[e].columnalign=t[e]}}}}},exports.MathTRElement=__decorate$c([element("math-tr")],exports.MathTRElement);var __decorate$d=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathLabeledTRElement=class extends MathTableBaseElement{render(){return html`
    <style>
      :host {
        display: table-row;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      slot::slotted(math-td:first-child) {
        display: none;
      }
      slot::slotted(math-td:last-child) {
        --math-table-column-border: none;
      }
    </style>
    <slot></slot>
    `}updated(e){super.updated(e),this.updateAlignment()}},exports.MathLabeledTRElement=__decorate$d([element("math-labeledtr")],exports.MathLabeledTRElement);var __decorate$e=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$6=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathTableElement=class extends MathTableBaseElement{constructor(){super(),this.columnlines="none",this.rowlines="none",this.frame="none",this.columnspacing="0.8em",this.rowspacing="0.8em",this.framespacing="0.4em 0.5ex",this.columnalign=this.columnalign||"center"}render(){return html`
    <style>
      :host {
        display: inline-table;
        border: var(--math-table-border, 'none');
        padding: var(--math-table-padding, 0.5ex 0.4em);
        width: var(--math-table-width);
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      slot::slotted(math-tr:last-child) {
        --math-table-row-border: none;
      }
    </style>
    <slot></slot>
    `}updated(e){super.updated(e),this.updateAlignment();const t=this.style;if(this.frame)switch(this.frame){case"none":t.setProperty("--math-table-border","none");break;case"solid":t.setProperty("--math-table-border","solid thin");break;case"dashed":t.setProperty("--math-table-border","dashed thin");break;default:t.removeProperty("--math-table-border");}if(this.rowlines)switch(this.rowlines){case"none":t.setProperty("--math-table-row-border","none");break;case"solid":t.setProperty("--math-table-row-border","solid thin");break;case"dashed":t.setProperty("--math-table-row-border","dashed thin");break;default:t.removeProperty("--math-table-row-border");}if(this.columnlines)switch(this.columnlines){case"none":t.setProperty("--math-table-column-border","none");break;case"solid":t.setProperty("--math-table-column-border","solid thin");break;case"dashed":t.setProperty("--math-table-column-border","dashed thin");break;default:t.removeProperty("--math-table-column-border");}if(this.framespacing){const e=this.framespacing.split(" ").reverse();t.setProperty("--math-table-padding",e.join(" "))}else t.removeProperty("--math-table-padding");if(this.width?t.setProperty("--math-table-width",this.width):t.removeProperty("--math-table-width"),this.columnspacing?t.setProperty("--math-table-columnspacing",this.columnspacing):t.removeProperty("--math-table-columnspacing"),this.rowspacing?t.setProperty("--math-table-rowspacing",this.columnspacing):t.removeProperty("--math-table-rowspacing"),this.columnalign){const e=this.columnalign.trim().split(" ").filter(e=>!!e.trim());if(1<e.length){const e=this.shadowRoot.querySelector("slot");e&&e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE).filter(e=>"MATH-TR"===e.tagName||"MATH-LABELEDTR"===e.tagName).forEach(e=>{const t=e;t.columnalign=t.columnalign||this.columnalign.trim()})}}}},__decorate$e([property({type:String}),__metadata$6("design:type",String)],exports.MathTableElement.prototype,"columnlines",void 0),__decorate$e([property({type:String}),__metadata$6("design:type",String)],exports.MathTableElement.prototype,"rowlines",void 0),__decorate$e([property({type:String}),__metadata$6("design:type",String)],exports.MathTableElement.prototype,"frame",void 0),__decorate$e([property({type:String}),__metadata$6("design:type",Object)],exports.MathTableElement.prototype,"columnspacing",void 0),__decorate$e([property({type:String}),__metadata$6("design:type",Object)],exports.MathTableElement.prototype,"rowspacing",void 0),__decorate$e([property({type:String}),__metadata$6("design:type",Object)],exports.MathTableElement.prototype,"framespacing",void 0),__decorate$e([property({type:String}),__metadata$6("design:type",String)],exports.MathTableElement.prototype,"width",void 0),exports.MathTableElement=__decorate$e([element("math-table"),__metadata$6("design:paramtypes",[])],exports.MathTableElement);var __decorate$f=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathSupElement=class extends MathMLElement{render(){return html`
    <style>
      ${HorizFlex}
      :host {
        display: inline-block;
        position: relative;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      ::slotted(:first-child) {
        padding-right: 0.16em;
      }
      ::slotted(:not(:first-child)) {
        font-size: 0.8em;
        --math-style-level: sub;
        position: absolute;
        left: 100%;
        opacity: 0;
        line-height: 1;
      }
    </style>
    <div class="horizontal layout">
      <slot @slotchange="${this.refreshSlot}"></slot>
    </div>
    `}refreshSlot(){if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("slot");if(!e)return;const t=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);1<t.length&&setTimeout(()=>{const e=t[0].getBoundingClientRect(),n=t[1],r=n.getBoundingClientRect();n.style.opacity="1";const o=[0,0],a=r.bottom-(e.bottom-e.height/2);0<a&&(n.style.top=`${-a}px`,o[0]=a),o[1]=r.width+5,this.style.margin=`${o[0]}px ${o[1]}px 0 0`},50)}},exports.MathSupElement=__decorate$f([element("math-sup")],exports.MathSupElement);var __decorate$g=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathSubElement=class extends MathMLElement{render(){return html`
    <style>
      ${HorizFlex}
      :host {
        display: inline-block;
        position: relative;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      ::slotted(:first-child) {
        padding-right: 0.1em;
        margin: 0;
      }
      ::slotted(:not(:first-child)) {
        font-size: 0.8em;
        --math-style-level: sub;
        position: absolute;
        left: 100%;
        opacity: 0;
        line-height: 1;
      }
    </style>
    <div class="horizontal layout">
      <slot @slotchange="${this.refreshSlot}"></slot>
    </div>
    `}refreshSlot(){if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("slot");if(!e)return;const t=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);1<t.length&&setTimeout(()=>{const e=t[0].getBoundingClientRect(),n=t[1],r=n.getBoundingClientRect();n.style.opacity="1";const o=[0,0],a=e.height/2;let d=a;a+r.height<e.height?d=e.height-r.height:o[0]=a+r.height-e.height,n.style.top=`${d}px`,o[1]=r.width+5,this.style.margin=`0 ${o[1]}px ${o[0]}px 0`},50)}},exports.MathSubElement=__decorate$g([element("math-sub")],exports.MathSubElement);var __decorate$h=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathSubSupElement=class extends MathMLElement{constructor(){super(...arguments),this.pendingLayout=!1}render(){return html`
    <style>
      ${HorizFlex}
      :host {
        display: inline-block;
        position: relative;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      ::slotted(:first-child) {
        padding-right: 0.16em;
      }
      ::slotted(:not(:first-child)) {
        font-size: 0.75em;
        --math-style-level: sub;
        position: absolute;
        left: 100%;
        opacity: 0;
        line-height: 1;
      }
    </style>
    <div class="horizontal layout">
      <slot @slotchange="${this.refreshSlot}"></slot>
    </div>
    `}refreshSlot(){if(this.pendingLayout)return;if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("slot");if(!e)return;const t=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);if(2<t.length){this.pendingLayout=!0;const e=()=>{const e=t[0].getBoundingClientRect(),n=t[1],r=t[2],o=n.getBoundingClientRect(),a=r.getBoundingClientRect();n.style.opacity="1",r.style.opacity="1";const d=[0,0,0],i=e.height/2;let l=i;i+o.height<e.height?l=e.height-o.height:d[2]=i+o.height-e.height,n.style.top=`${l}px`,d[1]=o.width+5,l=a.bottom-(e.bottom-e.height/2),0<l&&(r.style.top=`${-l}px`,d[0]=l),d[1]=Math.max(a.width+5,d[1]),this.style.margin=`${d[0]}px ${d[1]}px ${d[2]}px 0`};setTimeout(e,50),setTimeout(()=>{this.pendingLayout=!1,e()},500)}}},exports.MathSubSupElement=__decorate$h([element("math-subsup")],exports.MathSubSupElement);var __decorate$i=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathMultiScriptsElement=class extends MathMLElement{constructor(){super(...arguments),this.pendingLayout=!1}render(){return html`
    <style>
      ${AllFlex}
      :host {
        display: inline-block;
        position: relative;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      ::slotted(:first-child) {
        padding: 0 0.16em;
      }
      ::slotted(:not(:first-child)) {
        font-size: 0.75em;
        --math-style-level: sub;
        position: absolute;
        opacity: 0;
        line-height: 1;
      }
      ::slotted(.rightscript) {
        left: 100%;
      }
      ::slotted(.leftscript) {
        right: 100%;
      }
    </style>
    <div class="horizontal layout">
      <slot @slotchange="${this.refreshSlot}"></slot>
    </div>
    `}refreshSlot(){var e=Math.max;if(this.pendingLayout)return;if(!this.shadowRoot)return;const t=this.shadowRoot.querySelector("slot");if(!t)return;const r=t.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);if((1!==r.length||r[0].tagName!=="math-prescripts".toUpperCase())&&2<r.length){this.pendingLayout=!0;const t=()=>{const t=[null,null],o=[null,null];let a=t;for(let e=1;e<r.length;e++){const t=r[e];t.tagName==="math-prescripts".toUpperCase()?a=o:a[0]?!a[1]&&(a[1]=t):a[0]=t}const d=r[0].getBoundingClientRect(),n=[0,0,0,0];{if(t[0]){const e=t[0],r=e.getBoundingClientRect();e.style.opacity="1",e.classList.add("rightscript");const o=d.height/2;let a=o;o+r.height<d.height?a=d.height-r.height:n[2]=o+r.height-d.height,e.style.top=`${a}px`,n[1]=r.width+5}if(t[1]){const r=t[1];r.style.opacity="1",r.classList.add("rightscript");const o=r.getBoundingClientRect(),a=o.bottom-(d.bottom-d.height/2);0<a&&(r.style.top=`${-a}px`,n[0]=a),n[1]=e(o.width+5,n[1])}}{if(o[0]){const t=o[0],r=t.getBoundingClientRect();t.style.opacity="1",t.classList.add("leftscript");const a=d.height/2;let i=a;a+r.height<d.height?i=d.height-r.height:n[2]=e(a+r.height-d.height,n[2]),t.style.top=`${i}px`,n[3]=e(r.width+5,n[3])}if(o[1]){const t=o[1];t.style.opacity="1",t.classList.add("leftscript");const r=t.getBoundingClientRect(),a=r.bottom-(d.bottom-d.height/2);0<a&&(t.style.top=`${-a}px`,n[0]=e(a,n[0])),n[3]=e(r.width+5,n[3])}}this.style.margin=`${n[0]}px ${n[1]}px ${n[2]}px ${n[3]}px`};setTimeout(t,100),setTimeout(()=>{this.pendingLayout=!1,t()},800)}}},exports.MathMultiScriptsElement=__decorate$i([element("math-multiscripts")],exports.MathMultiScriptsElement);var __decorate$j=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathPreScriptsElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        width: 0;
        height: 0;
        display: none;
      }
    </style>
    `}},exports.MathPreScriptsElement=__decorate$j([element("math-prescripts")],exports.MathPreScriptsElement);var __decorate$k=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathNoneElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        height: 0;
        width: 0;
        padding: 0 3px;
      }
    </style>
    `}},exports.MathNoneElement=__decorate$k([element("math-none")],exports.MathNoneElement);var __decorate$l=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$7=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathOverElement=class extends MathMLElement{constructor(){super(...arguments),this.accent=!1,this.align="center"}render(){return html`
    <style>
      ${VertFlex}
      :host {
        display: inline-block;
        margin: 0 0.16em;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      .vertical.layout.reverse {
        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      }
      ::slotted(:not(:first-child)) {
        width: 100%;
        line-height: 1;
        margin: 0;
        text-align: var(--math-over-align, center);
        --math-style-level: sub;
        font-size: var(--math-over-font-size, 0.8em);
        --math-style-stretchy: true;
      }
    </style>
    <div class="vertical layout reverse">
      <slot></slot>
    </div>
    `}updated(e){super.updated(e);const t=this.style;switch(this.align){case"right":t.setProperty("--math-over-align","right");break;case"left":t.setProperty("--math-over-align","left");break;default:t.setProperty("--math-over-align","center");}t.setProperty("--math-over-font-size",this.accent?"1em":"0.8em")}},__decorate$l([property({type:Boolean,reflect:!0}),__metadata$7("design:type",Object)],exports.MathOverElement.prototype,"accent",void 0),__decorate$l([property(),__metadata$7("design:type",String)],exports.MathOverElement.prototype,"align",void 0),exports.MathOverElement=__decorate$l([element("math-over")],exports.MathOverElement);var __decorate$m=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$8=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathUnderElement=class extends MathMLElement{constructor(){super(...arguments),this.accentunder=!1,this.align="center"}render(){return html`
    <style>
      ${VertFlex}
      :host {
        display: inline-block;
        margin: 0 0.16em;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      ::slotted(:not(:first-child)) {
        width: 100%;
        line-height: 1;
        margin: 0;
        text-align: var(--math-under-align, center);
        --math-style-level: sub;
        font-size: var(--math-under-font-size, 0.8em);
        --math-style-stretchy: true;
      }
    </style>
    <div class="vertical layout">
      <slot></slot>
    </div>
    `}updated(e){super.updated(e);const t=this.style;switch(this.align){case"right":t.setProperty("--math-under-align","right");break;case"left":t.setProperty("--math-under-align","left");break;default:t.setProperty("--math-under-align","center");}t.setProperty("--math-under-font-size",this.accentunder?"1em":"0.8em")}},__decorate$m([property({type:Boolean,reflect:!0}),__metadata$8("design:type",Object)],exports.MathUnderElement.prototype,"accentunder",void 0),__decorate$m([property(),__metadata$8("design:type",String)],exports.MathUnderElement.prototype,"align",void 0),exports.MathUnderElement=__decorate$m([element("math-under")],exports.MathUnderElement);var __decorate$n=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$9=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathUnderOverElement=class extends MathMLElement{constructor(){super(...arguments),this.accent=!1,this.accentunder=!1,this.align="center"}render(){return html`
    <style>
      ${VertFlex}
      :host {
        display: inline-block;
        margin: 0 0.16em;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      .vertical.layout.reverse {
        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      }
      .under {
        width: 100%;
        line-height: 1;
        margin: 0;
        text-align: var(--math-underover-align, center);
        --math-style-level: sub;
        font-size: var(--math-under-font-size, 0.75em);
        --math-style-stretchy: true;
      }
      .over {
        width: 100%;
        line-height: 1;
        margin: 0;
        text-align: var(--math-underover-align, center);
        --math-style-level: sub;
        font-size: var(--math-over-font-size, 0.75em);
        --math-style-stretchy: true;
      }
      .base {
        margin: 0;
      }
    </style>
    <div id="muoPanel" class="vertical layout"></div>
    <div style="display: hidden;">
      <slot @slotchange="${this.refreshSlot}"></slot>
    </div>
    `}updated(e){super.updated(e);const t=this.style;switch(this.align){case"right":t.setProperty("--math-underover-align","right");break;case"left":t.setProperty("--math-underover-align","left");break;default:t.setProperty("--math-underover-align","center");}t.setProperty("--math-under-font-size",this.accentunder?"1em":"0.75em"),t.setProperty("--math-over-font-size",this.accent?"1em":"0.75em"),this.refreshSlot()}refreshSlot(){if(this.shadowRoot){const e=this.shadowRoot.querySelector("slot");if(e){const t=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);if(t.length){const e=this.shadowRoot.querySelector("#muoPanel");for(;e.firstChild;)e.removeChild(e.firstChild);2<t.length&&(t[2].classList.add("over"),e.appendChild(t[2])),t[0].classList.add("base"),e.append(t[0]),1<t.length&&(t[1].classList.add("under"),e.appendChild(t[1]))}}}}},__decorate$n([property({type:Boolean,reflect:!0}),__metadata$9("design:type",Object)],exports.MathUnderOverElement.prototype,"accent",void 0),__decorate$n([property({type:Boolean,reflect:!0}),__metadata$9("design:type",Object)],exports.MathUnderOverElement.prototype,"accentunder",void 0),__decorate$n([property(),__metadata$9("design:type",String)],exports.MathUnderOverElement.prototype,"align",void 0),exports.MathUnderOverElement=__decorate$n([element("math-underover")],exports.MathUnderOverElement);var __decorate$o=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathSqrtElement=class extends MathMLElement{render(){return html`
    <style>
      ${HorizFlex}
      :host {
        display: inline-block;
        vertical-align: bottom;
        align-self: center;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      .msqrtContent {
        padding: 1px 0.05em 0 0.2em;
        border-top: solid thin;
        white-space: nowrap;
      }
      #msqrtGlyphSpan {
        width: 1.1em;
        position: relative;
      }
      svg {
        position: absolute;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
      }
      path {
        fill: none;
        stroke: currentColor;
        stroke-width: 1;
      }
    </style>
    <div class="horizontal layout">
      <div id="msqrtGlyphSpan"><svg><path id="rootPath"></path></svg></div>
      <div class="flex msqrtContent"><slot @slotchange="${this.onSlotCange}"></slot></div>
    </div>
    `}updated(e){super.updated(e),this.onSlotCange()}onSlotCange(){if(this.shadowRoot){const e=this.shadowRoot.querySelector("slot");e&&setTimeout(()=>{this.drawRoot()},10)}}drawRoot(){const e=this.shadowRoot.querySelector("#msqrtGlyphSpan"),t=this.shadowRoot.querySelector("#rootPath");if(e&&t){const n=e.getBoundingClientRect(),r=n.width,o=n.height;t.setAttribute("d",`M0 ${.55*o} H${.13*r} L${.45*r} ${o-2} L${r} 0`)}}},exports.MathSqrtElement=__decorate$o([element("math-sqrt")],exports.MathSqrtElement);var __decorate$p=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathRootElement=class extends MathMLElement{render(){return html`
    <style>
      ${HorizFlex}
      :host {
        display: inline-block;
        vertical-align: bottom;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      .msqrtContent {
        padding: 1px 0.05em 0 0.2em;
        border-top: solid thin;
        white-space: nowrap;
      }
      #msqrtGlyphSpan {
        width: 1.1em;
        position: relative;
      }
      svg {
        position: absolute;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
      }
      path {
        fill: none;
        stroke: currentColor;
        stroke-width: 1;
      }
      ::slotted(:not(:first-child)) {
        font-size: 0.66em;
        position: absolute;
        top: 52%;
        right: 57%;
        transform: translate3d(-100%,-100%,0);
      }
    </style>
    <div class="horizontal layout" style="position: relative;">
      <div id="msqrtGlyphSpan"><svg><path id="rootPath"></path></svg></div>
      <div class="flex msqrtContent"><slot @slotchange="${this.onSlotCange}"></slot></div>
    </div>
    `}updated(e){super.updated(e),this.onSlotCange()}onSlotCange(){if(this.shadowRoot){const e=this.shadowRoot.querySelector("slot");e&&setTimeout(()=>{this.drawRoot()},10)}}drawRoot(){const e=this.shadowRoot.querySelector("#msqrtGlyphSpan"),t=this.shadowRoot.querySelector("#rootPath");if(e&&t){const n=e.getBoundingClientRect(),r=n.width,o=n.height;t.setAttribute("d",`M0 ${.55*o} H${.13*r} L${.45*r} ${o-2} L${r} 0`)}}},exports.MathRootElement=__decorate$p([element("math-root")],exports.MathRootElement);var __decorate$q=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$a=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathFracElement=class extends MathMLElement{constructor(){super(...arguments),this.bevelled=!1,this.numalign="center",this.denomalign="center"}render(){let e="stroke-width: 1;",t="border-top: solid thin;";return this.linethickness&&"0"===this.linethickness.trim().charAt(0)&&(e="stroke-width: 0;",t=""),html`
    <style>
      :host {
        display: inline-block;
        vertical-align: middle;
        align-self: self-start;
        margin: 0 0.16em;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      #mfracN, #mfracD {
        font-size: 0.9em;
        --math-style-level: sub;
      }
      #mfracPanel.unbevelled {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
      }
      #mfracPanel.bevelled {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
      }
      #mfracPanel.bevelled #mfracN{
        transform: translateY(-0.3em);
      }
      #mfracPanel.bevelled #mfracD{
        transform: translateY(0.3em);
      }
      #mfracDivider.unbevelled {
        width: 100%;
        border-top: 1px solid;
      }
      #bevelledDivider {
        min-width: 6px;
        position: relative;
        margin: 0 0.2em;
      }
      #unbevelledDivider {
        width: 100%;
        height: 0;
      }
      .hidden {
        display: none !important;
      }
      svg {
        position: absolute;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
      }
      path {
        fill: none;
        stroke: currentColor;
      }
    </style>
    <div id="mfracPanel">
      <div id="mfracN"></div>
      <div id="bevelledDivider" class="hidden">&nbsp;<svg><path id="bevelledPath" style="${e}"></path></svg></div>
      <div id="unbevelledDivider" style="${t}"></div>
      <div id="mfracD"></div>
    </div>
    <div style="display: hidden;"><slot @slotchange="${this.refreshSlot}"></slot></div>
    `}updated(e){super.updated(e),this.refreshSlot()}refreshSlot(){if(this.shadowRoot){const e=this.shadowRoot.querySelector("slot");if(e){const t=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);if(1<t.length){const e=this.shadowRoot.querySelector("#mfracN"),n=this.shadowRoot.querySelector("#mfracD");e.appendChild(t[0]),n.appendChild(t[1]);for(let e=2;e<t.length;e++)t[e].parentElement&&t[e].parentElement.removeChild(t[e])}this.updateBevlled()}}}updateBevlled(){const e=this.shadowRoot.querySelector("#mfracPanel"),t=this.shadowRoot.querySelector("#mfracN"),n=this.shadowRoot.querySelector("#mfracD"),r=this.shadowRoot.querySelector("#bevelledDivider"),o=this.shadowRoot.querySelector("#unbevelledDivider");t.style.textAlign=this.numalign,n.style.textAlign=this.denomalign,this.bevelled?(e.classList.remove("unbevelled"),e.classList.add("bevelled"),r.classList.remove("hidden"),o.classList.add("hidden"),setTimeout(()=>{this.drawBevelledDivider()},10)):(e.classList.remove("bevelled"),e.classList.add("unbevelled"),r.classList.add("hidden"),o.classList.remove("hidden"))}drawBevelledDivider(){const e=this.shadowRoot.querySelector("#bevelledDivider"),t=this.shadowRoot.querySelector("#bevelledPath");if(e&&t){const n=e.getBoundingClientRect(),r=n.width,o=n.height;t.setAttribute("d",`M0 ${o} L${r} 0`)}}},__decorate$q([property({type:Boolean}),__metadata$a("design:type",Object)],exports.MathFracElement.prototype,"bevelled",void 0),__decorate$q([property({type:String}),__metadata$a("design:type",String)],exports.MathFracElement.prototype,"numalign",void 0),__decorate$q([property({type:String}),__metadata$a("design:type",String)],exports.MathFracElement.prototype,"denomalign",void 0),__decorate$q([property({type:String}),__metadata$a("design:type",String)],exports.MathFracElement.prototype,"linethickness",void 0),exports.MathFracElement=__decorate$q([element("math-frac")],exports.MathFracElement);var __decorate$r=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$b=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};const SVGNS="http://www.w3.org/2000/svg";exports.MathEncloseElement=class extends MathMLElement{constructor(){super(...arguments),this.notation="longdiv"}render(){return html`
    <style>
      :host {
        display: inline-block;
        position: relative;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      svg {
        position: absolute;
        left: 0;
        top: 0;
        pointer-events: none;
      }
      ellipse, path {
        fill: none;
        stroke: currentColor;
        stroke-width: 1;
      }
    </style>
    <div id="menclosePanel"><slot @slotchange="${this.refresh}"></slot></div>
    <svg></svg>
    `}updated(e){super.updated(e),this.refresh()}refresh(){this.shadowRoot&&this.shadowRoot.querySelector("svg")&&this.shadowRoot.querySelector("slot")&&setTimeout(()=>this.redraw(),100)}adjustPadding(e,t){for(let n=0;n<t.length;n++)e[n]=Math.max(e[n],t[n])}redraw(){const e=this.shadowRoot.querySelector("svg"),n=this.shadowRoot.querySelector("#menclosePanel"),r=this.getBoundingClientRect(),o=[0,0,0,0],a=(this.notation||"").trim().split(" ").filter(e=>!!e.trim());a.forEach(e=>{switch(e){case"longdiv":this.adjustPadding(o,[2,0,0,12]);break;case"actuarial":this.adjustPadding(o,[2,2,0,0]);break;case"radical":this.adjustPadding(o,[2,0,0,18]);break;case"phasorangle":this.adjustPadding(o,[0,0,2,16]);break;case"circle":this.adjustPadding(o,[2,4,2,4]);break;default:this.adjustPadding(o,[1,1,1,1]);}}),n.style.padding=o.join("px ").trim()+"px";const d=r.width+o[1]+o[3],i=r.height+o[0]+o[2];for(e.style.width=`${d}px`,e.style.height=`${i}px`;e.firstChild;)e.removeChild(e.firstChild);n.style.borderTop=null,n.style.borderBottom=null,n.style.borderLeft=null,n.style.borderRight=null,n.style.borderRadius=null,a.forEach(r=>{var t=Math.cos,o=Math.sin,a=Math.PI;switch(r){case"longdiv":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M0 1 H ${d} M0 1 C 8 ${.33*i} 8 ${.66*i} 0 ${i}`),e.appendChild(t);break}case"actuarial":n.style.borderRight="1px solid",n.style.borderTop="1px solid";break;case"radical":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M0 ${.55*i} H${.13*18} L${.45*18} ${i-2} L${18} 1 L${d} 1`),e.appendChild(t);break}case"box":n.style.borderRight="1px solid",n.style.borderTop="1px solid",n.style.borderLeft="1px solid",n.style.borderBottom="1px solid";break;case"roundedbox":n.style.borderRight="1px solid",n.style.borderTop="1px solid",n.style.borderLeft="1px solid",n.style.borderBottom="1px solid",n.style.borderRadius="5px";break;case"circle":{const t=document.createElementNS(SVGNS,"ellipse");t.setAttribute("cx",`${d/2}`),t.setAttribute("cy",`${i/2}`),t.setAttribute("rx",`${d/2-2}`),t.setAttribute("ry",`${i/2-2}`),e.appendChild(t);break}case"left":n.style.borderLeft="1px solid";break;case"right":n.style.borderRight="1px solid";break;case"top":n.style.borderTop="1px solid";break;case"bottom":n.style.borderBottom="1px solid";break;case"madruwb":n.style.borderRight="1px solid",n.style.borderBottom="1px solid";break;case"updiagonalstrike":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M1 ${i-1} L${d-1} ${1}`),e.appendChild(t);break}case"downdiagonalstrike":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M1 1 L${d-1} ${i-1}`),e.appendChild(t);break}case"verticalstrike":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M${d/2} 1 L${d/2} ${i-1}`),e.appendChild(t);break}case"horizontalstrike":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M1 ${i/2} L${d-1} ${i/2}`),e.appendChild(t);break}case"updiagonalarrow":{const n=document.createElementNS(SVGNS,"path");n.setAttribute("d",`M1 ${i-1} L${d-1} ${1}`),e.appendChild(n);const r=Math.atan(i/d),l=a/2-r-a/6,s=a/6+l,p=8*o(l),h=8*t(l),c=document.createElementNS(SVGNS,"path");c.setAttribute("d",`M${d-1} ${1} L${d-1-p} ${1+h} l${8*-t(s)} ${8*-o(s)} Z`),c.style.fill="currentColor",e.appendChild(c);break}case"phasorangle":{const t=document.createElementNS(SVGNS,"path");t.setAttribute("d",`M16 1 L1 ${i-1} L${d} ${i-1}`),e.appendChild(t);break}default:}})}},__decorate$r([property({type:String}),__metadata$b("design:type",Object)],exports.MathEncloseElement.prototype,"notation",void 0),exports.MathEncloseElement=__decorate$r([element("math-enclose")],exports.MathEncloseElement);var __decorate$s=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathPhantomElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        visibility: hidden;
      }
    </style>
    <slot></slot>
    `}},exports.MathPhantomElement=__decorate$s([element("math-phantom")],exports.MathPhantomElement);var __decorate$t=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s};exports.MathErrorElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        background: rgb(255, 255, 221);
        border: 1px solid red;
        font-weight: bold;
        font-family: sans-serif;
        font-size: 1.1em;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}},exports.MathErrorElement=__decorate$t([element("math-error")],exports.MathErrorElement);var __decorate$u=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$c=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathFencedElement=class extends MathMLElement{constructor(){super(...arguments),this.close=")",this.open="(",this.separators=","}render(){return html`
    <style>
      ${HorizCenterFlex}
      :host {
        display: inline-block;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
      #mfencedRow {
        align-items: stretch;
      }
    </style>
    <div id="mfencedRow" class="horizontal layout center"></div>
    <div style="display: hidden;">
      <slot @slotchange="${this.refreshSlot}"></slot>
    </div>
    `}updated(e){super.updated(e),this.refreshSlot()}isStretchyString(e){return!e.match(/^[0-9a-zA-Z,;\-_`'"]*$/)}nextSeparator(e){return 0<=e&&this.separators.length?e<this.separators.length?this.separators.charAt(e):this.separators.charAt(this.separators.length-1):null}refreshSlot(){if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("slot"),t=this.shadowRoot.querySelector("#mfencedRow");if(e&&t){const n=e.assignedNodes().filter(e=>e.nodeType===Node.ELEMENT_NODE);if(n.length){for(;t.firstChild;)t.removeChild(t.firstChild);let e=0;for(let r=0;r<n.length;r++){if(0==r&&this.open){const e=new exports.MathOElement;this.isStretchyString(this.open.trim())&&(e.stretchy="true"),e.textContent=this.open,t.appendChild(e)}if(t.appendChild(n[r]),r<n.length-1){const n=this.nextSeparator(e);if(n){e++;const r=new exports.MathOElement;this.isStretchyString(n)&&(r.stretchy="true"),r.textContent=n,t.appendChild(r)}}if(r==n.length-1&&this.close){const e=new exports.MathOElement;this.isStretchyString(this.close.trim())&&(e.stretchy="true"),e.textContent=this.close,t.appendChild(e)}}}}}},__decorate$u([property({type:String}),__metadata$c("design:type",Object)],exports.MathFencedElement.prototype,"close",void 0),__decorate$u([property({type:String}),__metadata$c("design:type",Object)],exports.MathFencedElement.prototype,"open",void 0),__decorate$u([property({type:String}),__metadata$c("design:type",Object)],exports.MathFencedElement.prototype,"separators",void 0),exports.MathFencedElement=__decorate$u([element("math-fenced")],exports.MathFencedElement);var __decorate$v=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$d=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathPaddedElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <div id="mpaddedPanel"><slot></slot></div>
    `}updated(e){super.updated(e),this.refresh()}refresh(){if(!this.shadowRoot)return;const e=this.shadowRoot.querySelector("#mpaddedPanel");e&&setTimeout(()=>{const t=e.getBoundingClientRect();this.height?"+"===this.height.charAt(0)?this.style.paddingTop=this.height.substring(1):"-"===this.height.charAt(0)?(this.style.height=`calc(${t.height}px - ${this.height.substring(1)})`,this.style.paddingTop="0"):(this.style.height=this.height,this.style.paddingTop="0"):(this.style.height="auto",this.style.paddingTop="0"),this.style.width=this.width?"+"===this.width.charAt(0)||"-"===this.width.charAt(0)?`calc(${t.width}px + ${this.width.substring(1)})`:this.width:"auto"},50)}},__decorate$v([property({type:String}),__metadata$d("design:type",String)],exports.MathPaddedElement.prototype,"height",void 0),__decorate$v([property({type:String}),__metadata$d("design:type",String)],exports.MathPaddedElement.prototype,"width",void 0),exports.MathPaddedElement=__decorate$v([element("math-padded")],exports.MathPaddedElement);var __decorate$w=function(e,t,n,o){var a,l=arguments.length,s=3>l?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var p=e.length-1;0<=p;p--)(a=e[p])&&(s=(3>l?a(s):3<l?a(t,n,s):a(t,n))||s);return 3<l&&s&&Object.defineProperty(t,n,s),s},__metadata$e=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};exports.MathStyleElement=class extends MathMLElement{render(){return html`
    <style>
      :host {
        display: inline-block;
        color: var(--math-color, inherit);
        background: var(--math-background, inherit);
      }
    </style>
    <slot></slot>
    `}},__decorate$w([property({type:String}),__metadata$e("design:type",String)],exports.MathStyleElement.prototype,"displaystyle",void 0),exports.MathStyleElement=__decorate$w([element("math-style")],exports.MathStyleElement);
